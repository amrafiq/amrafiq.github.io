
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>Service-oriented architecture: Microservices and API</title>
   <meta name="author" content="Ali Muhammad Rafiq" />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- Typekit -->
   <script type="text/javascript" src="http://use.typekit.com/jpd0pfm.js"></script>
   <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
</head>
<body>



<div class="site">
  <div class="title">
    <a href="/">Ali Muhammad Rafiq</a>
  </div>
  

<link rel="shortcut icon" type="image/x-icon" href="tree.ico" />



<div id="post">

<p><strong>Service-oriented architecture: Microservices and API</strong></p>


<p>I'd like to acknowledge <a href="https://javabrains.io/">Java Brains</a> and <a href="https://courses.telusko.com/">Telusko</a> for helping me grasp microservices as well being the backbone of the development this post.</p>

<p>Back in the old days, before microservices, programs resided on the clients machine. When programmers wrote code for a client, it would be compiled down to the clients computer. As functionality was created, large complex code bases were created. As in, once a version of a software created, clients would install that version of the application onto their devices.</p>
   
<img src="old.png" alt="Back in the old days">
   
<p>Eventually, programmers were asked to create smaller modules, small independent parts, these modules are reusable and can be used on another application. Again, all of these smaller modules are one application and eventually, one large application of everything smushed together and is the final entity is deployed on one machine anyway. This is how it used to work on desktop applications.</p>

<img src="notsoold.png" alt="Modular application development">
   
 <p>Then came along two developments: web applications. People started moving away from applications that needed to be installed on their machines to applications that can be installed on a remote machine.</p>

<img src="remote.png" alt="Drake approves of server-side apps">
   
<p>This meant, you from your machine can access the application from your machine. The server will prepare the HTML and display the application on your device while it is deployed on the server.</p>
   
<img src="serverside.png" alt="Just deploy to the server">
   
<p>Instead of developers installing application to each users machine, they just install the application to one server. This is awesome because everyone gets automatic updates.</p>
   
   <p>Rather than deploying all the smush into one users device, it is deployed onto a server.</p>
   
   <p>Overtime, web applications have become bigger, better, more efficient. They are search engines, file storage apps, large e-commerce apps, and search engines.</p>
   
   <p>Having a monolithic architecture has some disadvantages because of this. 
      <p>It makes it difficult to deploy big applications: deploying to one small module can cause havoc as you need to test the entire application before you deploy to ensure nothing has broken or a new bug has been introduced.
         Scalability: some sites have traffic spikes. E.g. during holidays, e-commerce websites have a spike in traffic. Servers are increased when traffic increases and servers are reduced when traffic has reduced.</p> 
         
         <img src="scalability.png" alt="As traffic increases, servers increase">
         
         But imagine an entire e-commerce website deployed as one large application. When the servers scale up, other functionalities that aren't being used are being scaled up as well when only a small portion needed to be scaled up. Money is wasted here as only a small portion needed to be scaled up during high traffic.</p>
   
   <img src="extraservers.png" alt="As traffic increases, servers increase">
         
         <p>Here is an idea. Rather than having the entire application on one monolith. Why not deploy the application into smaller mini-applications. Then you can deploy these mini applications on different machines and have to talk to each other on the network.</p>
            
            <p>Each server has a seperate part of the website deployed as a seperate application. In an e-commerce website, the mini-applications talk to each other. Such as the shopping catalog talking to the web view app.</p>
         
         <img src="microservices.png" alt="Smaller apps talking to each other">
               
               <p>Each micro service can talk to each other over REST APIs in different languages and functionality of product. You now have several individual applications that do a small thing each, but act as one large application.</p>
            
            <img src="rest_api.png" alt="They talk to each other through REST APIs">
                  
                  <p>Advantages:</p>
                  <p>-Deployment flexibility</p>
                  <p>-Technology flexibility</p>
                   <p>-Can be scaled seperately</p>
   
   <p>Disvantages:</p>
      <p>-Deployment / architecture complexity</p>
      <p>-Service discovery</p>
   
   <p>Obviously there isn't a right or wrong way to deploy microservices and they're not better than monolithic services. Each time should evaluate when it should make sense to use a microservices architecture vs. something else.</p>

   <p>Let's discuss Representational state transfer (REST) now.</p>
   
   <p>Let's say we have a weather reporting application that we have developed for your phone. We want to be able to report the weather for all the major cities across the globe.</p>
   
   <p>Now getting the weather of all the major cities would require setting up a sensor in each of those cities. This will cost billions of dollars. Now that means, we need to gather all this data from somewhere.</p>
   
   <p>Thankfully, there are dynamic servers that have this data already gathered for us. They have the data that we need.</p>
   
   <p>The dynamic servers are ready to give us the data. We just need to use an API to connect us to that server. We need to know how many services the server provides and who we are to the server.</p>
   
   <p>There will be a servlet on the server that will give us the data. We make a request for the servlet and it will give us the data. This can be a response in HTML or XML/JSON format.
   
   <img src="servlets.png" alt="Our servlet provides us with XML/JSON response">
      
   <p>We can also, instead, create an object and return the object instead. We are converting an object into a state, or representatal state transfer using JSON or XML.</p>
      
   <img src="object.png" alt="Our servlet provides us with XML/JSON response">   
   
   <p>Finally, let's discus the operations that we use. Tradionally, we have used CRUD (Create Read Update Delete).</p>
   
   <p>So before, if I wanted to add two numbers, I would use the follow the following HTML request: amrafiq.github.io/add?num1=2&num2=4</p>
   
   <p>Instead, we can now use an object: amrafiq.github.io/questions?subject=answers so instead now, we are fetching a resource. We are now fetching data as it is. As a client you don't know what is happening on the server. Instead, you are just getting your response back.,/p>
      
   <p>C --> Create --> POST
   <p>R --> Read --> GET
   <p>U --> Update --> PUT
   <p>D --> Delete --> DELETE
      
   <p>Currently, REST is the most popular software architectural style. There are two popular implementations of REST: Jersey and Spring.</p>
      
</div>


  
  <div class="footer">
    <div class="contact">
      <p>
        Ali Muhammad Rafiq<br />
        Software Engineer
      </p>
    </div>
  </div>

</body>
</html>
